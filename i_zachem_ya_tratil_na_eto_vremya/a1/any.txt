/*/for (int i = 0; i < 6; i++) {
            if (boolMap[i]){
                BlockPos posI=Fun.getBlockByF(pos, Fun.dirs.get(i));
                BlockState stateI=world.getBlockState(posI);
                Block blockI=stateI.getBlock();
                if (BlocksInit.pistonBlocksRotate.contains(blockI)){
                    Direction rotateI=stateI.get(Properties.FACING);
                    if (Fun.dirs.get(i)==rotateI.getOpposite()){
                        return true;
                    }
                }else if (blockI==BlocksInit.pistonKnot){
                    Boolean[] boolMapI=getBool(stateI);
                    if (boolMapI[Fun.getOppositeDir.get(i)]){ //короче связка
                        return true;
                    }
                }else if (BlocksInit.pistonBlocks.contains(blockI)){
                    return true;
                }
            }
        }/*/
        {{
                /*/put(Direction.UP, Block.createCuboidShape(0, 0, 0, 16, 12, 16));
                put(Direction.DOWN, Block.createCuboidShape(0, 4, 0, 16, 16, 16));
                put(Direction.SOUTH, Block.createCuboidShape(0, 0, 0, 16, 16, 12));
                put(Direction.NORTH, Block.createCuboidShape(0, 0, 4, 16, 16, 16));
                put(Direction.EAST, Block.createCuboidShape(0, 0, 0, 12, 16, 16));
                put(Direction.WEST, Block.createCuboidShape(4, 0, 0, 16, 16, 16));/*/
            }}
            /**
             * <b>info about blocks:</b>
             * <ul>
             *     <li>knot0 is 4</li>
             *     <li>knot1 is 1</li>
             *     <li>knot2 is 2 (true, true, false, false)</li>
             *     <li>knot3 is 2 (true, false, true, false)</li>
             *     <li>knot4 is 3</li>
             * </ul>
             */
             /*/pistonKnot0=Registry.register(
                             Registries.BLOCK,
                             Identifier.of(MODID, "piston_knot0"),
                             new pistonKnot0Class(
                                     AbstractBlock.Settings.create()
                             )
                     );

                     pistonKnot1=Registry.register(
                             Registries.BLOCK,
                             Identifier.of(MODID, "piston_knot1"),
                             new pistonKnot1Class(
                                     AbstractBlock.Settings.create()
                             )
                     );

                     pistonKnot2=Registry.register(
                             Registries.BLOCK,
                             Identifier.of(MODID, "piston_knot2"),
                             new pistonKnot2Class(
                                     AbstractBlock.Settings.create()
                             )
                     );/*/
                     @Override
                         protected List<ItemStack> getDroppedStacks(BlockState state, LootContextParameterSet.Builder builder) {
                             System.out.println("drop!");
                             ItemStack ret=new ItemStack(this, 1);
                             /*/NbtCompound nbt2 = (NbtCompound)
                                     BlockState.CODEC
                                             .encodeStart(NbtOps.INSTANCE, state)
                                             .result()
                                             .orElse(null);/*/
                             /*/Optional<NbtCompound> nbt2 = BlockState.CODEC
                                     .encodeStart(NbtOps.INSTANCE, state)
                                     .result()
                                     .flatMap(nbtE -> Optional.of((NbtCompound) nbtE));
                             BlockStateComponent nbt=DataComponentTypes.BLOCK_STATE
                                     .getCodec()
                                     ;/*/
                             BlockStateComponent nbt=new BlockStateComponent(
                                     state.getEntries().entrySet().stream()
                                     .collect(java.util.stream.Collectors.toMap(
                                             entry -> entry.getKey().getName(),
                                             entry -> entry.getValue().toString())
                                     )
                             );
                             ret.set(DataComponentTypes.BLOCK_STATE, nbt);
                             return List.of(ret);
                         }
                         /*/*stack.damage(1, world, player,
                                             item -> {
                                                 // Предмет сломан → уменьшаем стек
                                                 stack.decrement(1);

                                                 // Анимация поломки
                                                 if (player != null) {
                                                     player.sendEquipmentBreakStatus(useItem, hand2);
                                                 }
                                             });/*/
                                             /*/spruceTrapdoorDoor=Registry.register(
                                                             Registries.BLOCK,
                                                             Identifier.of(MODID, "spruce_trapdoor_door"),
                                                             new trapdoorDoorClass(BlockSetType.SPRUCE, pistonSETTINGS)
                                                     );
                                                     spruceTrapdoorDoorI=Registry.register(
                                                             Registries.ITEM,
                                                             Identifier.of(MODID, "spruce_trapdoor_door"),
                                                             new BlockItem(spruceTrapdoorDoor,
                                                                     new Item.Settings()
                                                             )
                                                     );

                                                     birchTrapdoorDoor=Registry.register(
                                                             Registries.BLOCK,
                                                             Identifier.of(MODID, "birch_trapdoor_door"),
                                                             new trapdoorDoorClass(BlockSetType.BIRCH, pistonSETTINGS)
                                                     );
                                                     birchTrapdoorDoorI=Registry.register(
                                                             Registries.ITEM,
                                                             Identifier.of(MODID, "birch_trapdoor_door"),
                                                             new BlockItem(birchTrapdoorDoor,
                                                                     new Item.Settings()
                                                             )
                                                     );

                                                     jungleTrapdoorDoor=Registry.register(
                                                             Registries.BLOCK,
                                                             Identifier.of(MODID, "jungle_trapdoor_door"),
                                                             new trapdoorDoorClass(BlockSetType.JUNGLE, pistonSETTINGS)
                                                     );
                                                     jungleTrapdoorDoorI=Registry.register(
                                                             Registries.ITEM,
                                                             Identifier.of(MODID, "jungle_trapdoor_door"),
                                                             new BlockItem(jungleTrapdoorDoor,
                                                                     new Item.Settings()
                                                             )
                                                     );/*/

    //public static Block spruceTrapdoorDoor;
    //public static Item spruceTrapdoorDoorI;
    //public static Block birchTrapdoorDoor;
    //public static Item birchTrapdoorDoorI;
    //public static Block jungleTrapdoorDoor;
    //public static Item jungleTrapdoorDoorI;
    //public static Block bambooTrapdoorDoor;
    //public static Item bambooTrapdoorDoorI;

            /*/trapdoorDoorsI.add(
                    Registry.register(
                            Registries.ITEM,
                            Identifier.of(MODID, name),
                            new BlockItem(trapdoorDoors.getLast(),
                                    new Item.Settings()
                            )
                    )
            );/*/

    /*
     * What? new Item? not mixined? GO AWAY VANILLA NEW ITEM, GO AWAY!!! I HATE YOU!
     */
    /*/@Unique
    public void delete(RegistryKey<T> key) {
        RegistryEntry.Reference<T> reference = this.keyToEntry.get(key);
        if (reference == null) {
            return;
        }

        T value = reference.value();

        this.keyToEntry.remove(key);
        this.idToEntry.remove(key.getValue());
        this.valueToEntry.remove(value);
        this.keyToEntryInfo.remove(key);

        int index = this.entryToRawId.getInt(value);
        if (index >= 0 && index < this.rawIdToEntry.size()) {
            this.rawIdToEntry.remove(index);
        }

        for (int i = 0; i < this.rawIdToEntry.size(); i++) {
            RegistryEntry.Reference<T> ref = this.rawIdToEntry.get(i);
            this.entryToRawId.put(ref.value(), i);
        }
    }/*/
    //public static HashMap<String, Block> trapdoorDoorsAtHash=new HashMap<>();
            //trapdoorDoorsAtHash.put(type, trapdoorDoors.getLast());
            @Override
                public void tick() {
                    super.tick();
                    VoxelShape voxelShape;
                    boolean bl = this.isNoClip();
                    Vec3d vec3d = this.getVelocity();
                    if (this.prevPitch == 0.0f && this.prevYaw == 0.0f) {
                        double d = vec3d.horizontalLength();
                        this.setYaw((float)(MathHelper.atan2(vec3d.x, vec3d.z) * 57.2957763671875));
                        this.setPitch((float)(MathHelper.atan2(vec3d.y, d) * 57.2957763671875));
                        this.prevYaw = this.getYaw();
                        this.prevPitch = this.getPitch();
                    }
                    BlockPos blockPos = this.getBlockPos();
                    BlockState blockState = this.getWorld().getBlockState(blockPos);
                    if (!(blockState.isAir() || bl || (voxelShape = blockState.getCollisionShape(this.getWorld(), blockPos)).isEmpty())) {
                        Vec3d vec3d2 = this.getPos();
                        for (Box box : voxelShape.getBoundingBoxes()) {
                            if (!box.offset(blockPos).contains(vec3d2)) continue;
                            this.inGround = true;
                            break;
                        }
                    }
                    if (this.shake > 0) {
                        --this.shake;
                    }
                    if (this.isTouchingWaterOrRain() || blockState.isOf(Blocks.POWDER_SNOW)) {
                        this.extinguish();
                    }
                    boolean onGround=this.inGround && !bl;
                    if (onGround) {
                        if (inBlockState != blockState && this.shouldFall()) {
                            this.fall();
                        } else if (!this.getWorld().isClient) {
                            this.age();
                        }
                        inGroundTime++;
                    }else{
                        inGroundTime = 0;
                    }
                    Vec3d vec3d3 = this.getPos();
                    Vec3d vec3d2 = vec3d3.add(
                            vec3d.length()==0 ? new Vec3d(0, 0.5, 0) : vec3d
                    );
                    Vec3d vec3d2_=vec3d2 = vec3d3.add(vec3d);
                    HitResult hitResult = this.getWorld().raycast(new RaycastContext(vec3d3, vec3d2, RaycastContext.ShapeType.COLLIDER, RaycastContext.FluidHandling.NONE, this));
                    if (hitResult.getType() != HitResult.Type.MISS) {
                        vec3d2 = hitResult.getPos();
                    }
                    while (!this.isRemoved()) {
                        EntityHitResult entityHitResult = this.getEntityCollision(vec3d3, vec3d2);
                        if (entityHitResult != null) {
                            hitResult = entityHitResult;
                        }
                        if (hitResult != null && !bl) {
                            ProjectileDeflection projectileDeflection = this.hitOrDeflect(hitResult);
                            this.velocityDirty = true;
                            if (projectileDeflection != ProjectileDeflection.NONE) break;
                        }
                        if (entityHitResult == null || this.getPierceLevel() <= 0) break;
                        hitResult = null;
                    }
                    if (!onGround) {
                        if (vec3d.length()!=0){
                            vec3d = this.getVelocity();
                        }
                        double e = vec3d.x;
                        double f = vec3d.y;
                        double g = vec3d.z;
                        if (this.isCritical()) {
                            for (int i = 0; i < 4; ++i) {
                                this.getWorld().addParticle(ParticleTypes.CRIT, this.getX() + e * (double) i / 4.0, this.getY() + f * (double) i / 4.0, this.getZ() + g * (double) i / 4.0, -e, -f + 0.2, -g);
                            }
                        }
                        double h = this.getX() + e;
                        double j = this.getY() + f;
                        double k = this.getZ() + g;
                        double l = vec3d.horizontalLength();
                        if (bl) {
                            this.setYaw((float) (MathHelper.atan2(-e, -g) * 57.2957763671875));
                        } else {
                            this.setYaw((float) (MathHelper.atan2(e, g) * 57.2957763671875));
                        }
                        this.setPitch((float) (MathHelper.atan2(f, l) * 57.2957763671875));
                        this.setPitch(PersistentProjectileEntity.updateRotation(this.prevPitch, this.getPitch()));
                        this.setYaw(PersistentProjectileEntity.updateRotation(this.prevYaw, this.getYaw()));
                        float m = 0.99f;
                        if (this.isTouchingWater()) {
                            for (int n = 0; n < 4; ++n) {
                                float o = 0.25f;
                                this.getWorld().addParticle(ParticleTypes.BUBBLE, h - e * 0.25, j - f * 0.25, k - g * 0.25, e, f, g);
                            }
                            m = this.getDragInWater();
                        }
                        this.setVelocity(vec3d.multiply(m));
                        if (!bl) {
                            this.applyGravity();
                        }
                        this.setPosition(h, j, k);
                        this.checkBlockCollision();
                    }
                }
                boolean onGround=this.inGround;
                        Vec3d vec3d = this.getVelocity();
                        if (this.prevPitch == 0.0f && this.prevYaw == 0.0f) {
                            double d = vec3d.horizontalLength();
                            this.setYaw((float)(MathHelper.atan2(vec3d.x, vec3d.z) * 57.2957763671875));
                            this.setPitch((float)(MathHelper.atan2(vec3d.y, d) * 57.2957763671875));
                            this.prevYaw = this.getYaw();
                            this.prevPitch = this.getPitch();
                        }
                        BlockPos blockPos = this.getBlockPos();
                        BlockState blockState = this.getWorld().getBlockState(blockPos);
                        if (!(blockState.isAir() || this.noClip || (voxelShape = blockState.getCollisionShape(this.getWorld(), blockPos)).isEmpty())) {
                            Vec3d vec3d2 = this.getPos();
                            for (Box box : voxelShape.getBoundingBoxes()) {
                                if (!box.offset(blockPos).contains(vec3d2)) continue;
                                this.inGround = true;
                                break;
                            }
                        }
                        if (this.shake > 0) {
                            --this.shake;
                        }
                        if (this.isTouchingWaterOrRain() || blockState.isOf(Blocks.POWDER_SNOW)) {
                            this.extinguish();
                        }
                        if (onGround) {
                            if (this.inBlockState != blockState && this.shouldFall()) {
                                this.fall();
                            } else if (!this.getWorld().isClient) {
                                this.age();
                            }
                            this.inGroundTime++;
                        }else{
                            this.inGroundTime = 0;
                        }
                        Vec3d vec3d3 = this.getPos();
                        Vec3d vec3d2=vec3d3.add(vec3d);
                        Vec3d vec3d2_;
                        Vec3d vec3d3_;
                        if (inGround){
                            vec3d2_=vec3d3.add(0.25, 0.5, 0.25);
                            vec3d3_=vec3d3.add(-0.25, 0, -0.25);
                        }else{
                            vec3d2_=vec3d3.add(vec3d);
                            vec3d3_=vec3d3;
                        }
                        HitResult hitResult = this.getWorld().raycast(new RaycastContext(vec3d3, vec3d2, RaycastContext.ShapeType.COLLIDER, RaycastContext.FluidHandling.NONE, this));
                        if (hitResult.getType() != HitResult.Type.MISS) {
                            vec3d2 = hitResult.getPos();
                        }
                        while (!this.isRemoved()) {
                            EntityHitResult entityHitResult = this.getEntityCollision(vec3d3_, vec3d2_);
                            if (entityHitResult != null) {
                                hitResult = entityHitResult;
                            }
                            if (hitResult != null && hitResult.getType() == HitResult.Type.ENTITY) {
                                Entity entity = ((EntityHitResult)hitResult).getEntity();
                                Entity entity2 = this.getOwner();
                                if (entity instanceof PlayerEntity && entity2 instanceof PlayerEntity && !((PlayerEntity)entity2).shouldDamagePlayer((PlayerEntity)entity)) {
                                    hitResult = null;
                                    entityHitResult = null;
                                }
                            }
                            if (hitResult != null) {
                                ProjectileDeflection projectileDeflection = this.hitOrDeflect(hitResult);
                                this.velocityDirty = true;
                                if (projectileDeflection != ProjectileDeflection.NONE) break;
                            }
                            if (entityHitResult == null || this.getPierceLevel() <= 0) break;
                            hitResult = null;
                        }
                        if (!onGround){
                            vec3d = this.getVelocity();
                            double e = vec3d.x;
                            double f = vec3d.y;
                            double g = vec3d.z;
                            if (this.isCritical()) {
                                for (int i = 0; i < 4; ++i) {
                                    this.getWorld().addParticle(ParticleTypes.CRIT, this.getX() + e * (double)i / 4.0, this.getY() + f * (double)i / 4.0, this.getZ() + g * (double)i / 4.0, -e, -f + 0.2, -g);
                                }
                            }
                            double h = this.getX() + e;
                            double j = this.getY() + f;
                            double k = this.getZ() + g;
                            double l = vec3d.horizontalLength();
                            if (this.noClip) {
                                this.setYaw((float)(MathHelper.atan2(-e, -g) * 57.2957763671875));
                            } else {
                                this.setYaw((float)(MathHelper.atan2(e, g) * 57.2957763671875));
                            }
                            this.setPitch((float)(MathHelper.atan2(f, l) * 57.2957763671875));
                            this.setPitch(PersistentProjectileEntity.updateRotation(this.prevPitch, this.getPitch()));
                            this.setYaw(PersistentProjectileEntity.updateRotation(this.prevYaw, this.getYaw()));
                            float m = 0.99f;
                            if (this.isTouchingWater()) {
                                for (int n = 0; n < 4; ++n) {
                                    float o = 0.25f;
                                    this.getWorld().addParticle(ParticleTypes.BUBBLE, h - e * 0.25, j - f * 0.25, k - g * 0.25, e, f, g);
                                }
                                m = this.getDragInWater();
                            }
                            this.setVelocity(vec3d.multiply(m));
                            if (!this.noClip) {
                                this.applyGravity();
                            }
                            this.setPosition(h, j, k);
                            this.checkBlockCollision();
                        }
                        /*/if (age>min_tick_to_physis){
                            this.checkBlockCollision();
                        }/*/
        BlockState blockState = this.getWorld().getBlockState(blockHitResult.getBlockPos());
        blockState.onProjectileHit(this.getWorld(), blockState, blockHitResult, this);

        inBlockState = this.getWorld().getBlockState(blockHitResult.getBlockPos());
        if ((Object) this instanceof PersistentProjectileEntityFixerInterface thisFixed){
            thisFixed.superOnBlockHit(blockHitResult);
        }
        Vec3d vec3d = blockHitResult.getPos().subtract(this.getX(), this.getY(), this.getZ());
        this.setVelocity(vec3d);
        ItemStack itemStack = this.getWeaponStack();
        if (world instanceof ServerWorld) {
            ServerWorld serverWorld = (ServerWorld)world;
            if (itemStack != null) {
                this.onBlockHitEnchantmentEffects(serverWorld, blockHitResult, itemStack);
            }
        }
        Vec3d vec3d2 = vec3d.normalize().multiply(0.05f);
        this.setPos(this.getX() - vec3d2.x, this.getY() - vec3d2.y, this.getZ() - vec3d2.z);
        this.inGround = true;
        this.shake = 7;
        this.setCritical(false);
        this.setPierceLevel((byte)0);
        this.clearPiercingStatus();

    /*/@Override
    public boolean deflect(ProjectileDeflection deflection, @Nullable Entity deflector, @Nullable Entity owner, boolean fromAttack) {
        return true;
    }

    @Override
    protected ProjectileDeflection hitOrDeflect(HitResult hitResult) {
        //super.hitOrDeflect()
        EntityHitResult entityHitResult;
        Entity entity;
        ProjectileDeflection projectileDeflection;
        if (hitResult.getType() == HitResult.Type.ENTITY && (projectileDeflection = (entity = (entityHitResult = (EntityHitResult)hitResult).getEntity()).getProjectileDeflection(this)) != ProjectileDeflection.NONE) {
            if (entity != this.lastDeflectedEntity) {
                this.lastDeflectedEntity = entity;
            }
            return projectileDeflection;
        }
        this.onCollision(hitResult);
        return ProjectileDeflection.NONE;
    }

    @Override
    protected void onCollision(HitResult hitResult) {
        HitResult.Type type = hitResult.getType();
        if (type == HitResult.Type.ENTITY) {
            EntityHitResult entityHitResult = (EntityHitResult)hitResult;
            Entity entity = entityHitResult.getEntity();
            if (entity.getType().isIn(EntityTypeTags.REDIRECTABLE_PROJECTILE) && entity instanceof ProjectileEntity) {
                ProjectileEntity projectileEntity = (ProjectileEntity)entity;
                projectileEntity.deflect(ProjectileDeflection.REDIRECTED, this.getOwner(), this.getOwner(), true);
            }
            this.onEntityHit(entityHitResult);
            this.getWorld().emitGameEvent(GameEvent.PROJECTILE_LAND, hitResult.getPos(), GameEvent.Emitter.of(this, null));
        } else if (type == HitResult.Type.BLOCK) {
            BlockHitResult blockHitResult = (BlockHitResult)hitResult;
            this.onBlockHit(blockHitResult);
            BlockPos blockPos = blockHitResult.getBlockPos();
            this.getWorld().emitGameEvent(GameEvent.PROJECTILE_LAND, blockPos, GameEvent.Emitter.of(this, this.getWorld().getBlockState(blockPos)));
        }
    }/*/
    FeatureContext<?> context = new FeatureContext<>(
                    Optional.of(treeF),
                    (StructureWorldAccess) world,
                    ((ServerWorld) world).getChunkManager().getChunkGenerator(),
                    world.getRandom(),
                    pos,
                    treeF.config()
            );
            @SuppressWarnings("unchecked")
                @Override
                public Brain<ItemZombieEntity> getBrain() {
                    return (Brain<ItemZombieEntity>) super.getBrain();
                }

                @Override
                protected Brain.Profile<ItemZombieEntity> createBrainProfile() {
                    return Brain.createProfile(ItemZombieEntityBrain.memoryModules, ItemZombieEntityBrain.sensors);
                }

                @Override
                protected Brain<?> deserializeBrain(Dynamic<?> dynamic) {
                    return ItemZombieEntityBrain.create(this, this.createBrainProfile().deserialize(dynamic));
                }

                @Override
                protected void mobTick() {
                    World world = getWorld();
                    Profiler profiler = world.getProfiler();
                    profiler.push("item_zombie_entity");
                    this.getBrain().tick((ServerWorld) world, this);
                    profiler.swap("item_zombie_entity_activity_update");
                    ItemZombieEntityBrain.updateActivities(this);
                    profiler.pop();
                }

                @Override
                public @Nullable LivingEntity getTarget() {
                    return getTargetInBrain();
                }

                public Optional<LivingEntity> getHurtBy() {
                    return brain.getOptionalRegisteredMemory(MemoryModuleType.HURT_BY)
                            .map(DamageSource::getAttacker)
                            .filter(attacker -> attacker instanceof LivingEntity)
                            .map(attacker -> (LivingEntity) attacker);
                }